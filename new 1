main:

BL ArrayBuilder

MOVZ X1, #0, LSL #0
MOVZ X2, #40, LSL #0
BL Swap

MOVZ X1, #8, LSL #0
MOVZ X2, #24, LSL #0
BL Swap

MOVZ X1, #16, LSL #0
MOVZ X2, #80, LSL #0
BL Swap

MOVZ X1, #48, LSL #0
MOVZ X2, #88, LSL #0
BL Swap

DUMP

MOVZ X1, #88, LSL #0
BL SelectionSort

MOVZ X1, #43, LSL #0
BL BinarySearchIterative

DUMP

B mainEnd

ArrayBuilder:

	SUBI SP, SP, #8
	STUR LR, [SP, #0]

	//For now this function is hard coded to fill 12 arrays with the alphabet starting at address 0
	ADDI X0, X0, #65
	ADDI X1, X1, #66
	ADDI X2, X2, #67
	ADDI X3, X3, #68
	ADDI X4, X4, #69
	ADDI X5, X5, #70
	ADDI X6, X6, #71
	ADDI X7, X7, #72
	ADDI X8, X8, #73
	ADDI X9, X9, #74
	ADDI X10, X10, #75
	ADDI X11, X11, #76
	
	STUR X0, [XZR, #0]
	STUR X1, [XZR, #8]
	STUR X2, [XZR, #16]
	STUR X3, [XZR, #24]
	STUR X4, [XZR, #32]
	STUR X5, [XZR, #40]
	STUR X6, [XZR, #48]
	STUR X7, [XZR, #56]
	STUR X8, [XZR, #64]
	STUR X9, [XZR, #72]
	STUR X10, [XZR, #80]
	STUR X11, [XZR, #88]
	
	LDUR X9, [SP, #0]
	ADDI SP, SP, #8
	//DUMP
	BR X9

Swap: //Parameters(X1 Int0, X2 Int1)
	
	//Start
	SUBI SP, SP, #8		//Make space on stack
	STUR LR, [SP, #0]	//Store link register
	
	//Body
	LDUR X9, [X1, #0]
	LDUR X10, [X2, #0]
	STUR X10, [X1, #0]
	STUR X9, [X2, #0]
	
	//End
	LDUR X9, [SP, #0]
	ADDI SP, SP, #8
	//DUMP
	BR X9

MinIndex: //Parameters (X0 start, X1 array length)
//Note: this function returns the index that contains the smallest value

	SUBI SP, SP, #8 //makes space on the stack
	STUR LR, [SP, #0] //stores link register

	MOVZ X10, #0, LSL #0
	MOVZ X11, #0, LSL #0

	ADD X10, X10, X0
	ADDI X10, X10, #8 //i = start + 1
	ADD X11, X11, X0  //minIndex
	
	MinIndex_for_loop:
	
		//if (i > array length) exit
		SUBS X14, X10, X1
		B.GT MinIndex_end
		
		//if i < minIndex
		LDUR X12, [X10, #0] //array[i]
		LDUR X13, [X11, #0] //array[minIndex]
		SUBS X14, X13, X12
		B.GT MinIndex_less_than
		
		B Skip
		
		MinIndex_less_than:
			MOVZ X11, #0, LSL #0
			ADD X11, X11, X10
			
		Skip:
			ADDI X10, X10, #8
			B MinIndex_for_loop

	MinIndex_end:
		LDUR X9, [SP, #0]
		ADDI SP, SP, #8
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X11
		//DUMP
		BR X9

SelectionSort: //Parameters (X1 arrayLength)
	SUBI SP, SP, #24 //makes space on the stack
	STUR LR, [SP, #0] //stores link register
	STUR X1, [SP, #8] //stores arrayLength
	STUR XZR, [SP, #16] //stores swapIndex
	
	//init. vars
	MOVZ X9, #0, LSL #0		//swapIndex
	
	//stores into stack
	STUR X9, [SP, #16]
	
	SelectionSortWhile:
	
		LDUR X1, [SP, #8]
	
		//if (swapIndex >= arrayLength) end
		SUBS X17, X9, X1
		B.GE SelectionSortEnd
		
		//startIndex = currentIndex
		MOVZ X0, #0, LSL #0
		ADD X0, X0, X9
		
		//Load in the arrayLength
		LDUR X1, [SP, #8]
		
		//find min and swap it with the swapIndex
		BL MinIndex //(X0 startIndex, X1 arrayLength)
		
		MOVZ X1, #0, LSL #0
		ADD X1, X1, LR 		//minIndex
		LDUR X2, [SP, #16]  //swapIndex
		
		BL Swap //(X1, X2)
		
		//swapIndex += 1
		LDUR X9, [SP, #16]
		ADDI X9, X9, #8
		STUR X9, [SP, #16]
		
		B SelectionSortWhile
	
	SelectionSortEnd:
		LDUR X9, [SP, #0]
		ADDI SP, SP, #24
		BR X9

BinarySearchIterative: //Parameters(array, X1 left, X2 right, X3 targetValue)
//Note: Returns the index of the target value 

	SUBI SP, SP, #8 //makes space on the stack
	STUR LR, [SP, #0] //stores link register

	iterative_loop: 
		
		//if left > right, we exit
		SUBS X14, X1, X2 
		B.GT end_iterative //exits 

		MOVZ X10, #0, LSL #0 //initializing X10 = 0, represents mid value
		ADD X10, X1, X2 //mid = left + right 
		MOVZ X17, #2, LSL #0 //X17 = 2, gives a register with value 2[?]
		UDIV X10, X10, X17 //X10 = X10 / 2 [MID]
		LDUR X11, [X10, #0] //array[mid]

		SUBS X14, X11, X3 //if array[mid] == targetValue
		B.EQ result_iterative //has to return mid value
		B.LT lessThan_iterative //am i even allowed to do this???? 
		B.GT greaterThan_iterative 
		
		//SUBS X14, X11, X3 

	result_iterative: //SHOULD return mid value

		LDUR X9, [SP, #0]
		ADDI SP, SP, #8
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X10
		BR X9
	
	lessThan_iterative:

		ADDI X1, X10, #8 //left = mid + 1, is it 8 or 1??
		B iterative_loop //goes through the while loop again?

	greaterThan_iterative:
		
		SUBI X2, X10, #8 //right = mid - 1
		B iterative_loop

	end_iterative: 

		LDUR X9, [SP, #0]
		ADDI SP, SP, #8
		MOVZ LR, #0, LSL #0
		ADD LR, LR, X10 //ummmm hmmmm, what do i do to Return -1??
		BR X9 
	

mainEnd:
